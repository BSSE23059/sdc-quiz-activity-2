<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/phase-2/Jenkinsfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/phase-2/Jenkinsfile" />
              <option name="originalContent" value="pipeline {&#10;    agent any&#10;&#10;    parameters {&#10;        string(name: 'DOCKER_REGISTRY', defaultValue: 'localhost:5000', description: 'Docker Registry URL')&#10;        string(name: 'IMAGE_NAME', defaultValue: 'registration-app', description: 'Docker Image Name')&#10;        string(name: 'KUBE_NAMESPACE', defaultValue: 'default', description: 'Kubernetes Namespace')&#10;    }&#10;&#10;    environment {&#10;        DOCKER_REGISTRY = &quot;${params.DOCKER_REGISTRY}&quot;&#10;        IMAGE_NAME = &quot;${params.IMAGE_NAME}&quot;&#10;        IMAGE_TAG = &quot;${BUILD_NUMBER}&quot;&#10;        FULL_IMAGE_NAME = &quot;${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}&quot;&#10;        LATEST_IMAGE = &quot;${DOCKER_REGISTRY}/${IMAGE_NAME}:latest&quot;&#10;        KUBE_NAMESPACE = &quot;${params.KUBE_NAMESPACE}&quot;&#10;        APP_DIRECTORY = &quot;phase-2&quot;&#10;        GIT_COMMIT_MSG = &quot;Jenkins CI/CD Pipeline Build #${BUILD_NUMBER}&quot;&#10;    }&#10;&#10;    options {&#10;        buildDiscarder(logRotator(numToKeepStr: '10'))&#10;        timestamps()&#10;        timeout(time: 30, unit: 'MINUTES')&#10;    }&#10;&#10;    stages {&#10;        stage('Checkout') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: CHECKOUT ==========&quot;&#10;                    echo &quot;Checking out code from repository...&quot;&#10;                    checkout scm&#10;                    sh '''&#10;                        echo &quot;Git branch: $(git rev-parse --abbrev-ref HEAD)&quot;&#10;                        echo &quot;Git commit: $(git rev-parse --short HEAD)&quot;&#10;                        echo &quot;Git log:&quot;&#10;                        git log --oneline -5&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Build') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: BUILD ==========&quot;&#10;                    echo &quot;Building Docker image: ${FULL_IMAGE_NAME}&quot;&#10;                    &#10;                    dir(&quot;${APP_DIRECTORY}/app&quot;) {&#10;                        sh '''&#10;                            echo &quot;Building Docker image...&quot;&#10;                            docker build \&#10;                                -t ${FULL_IMAGE_NAME} \&#10;                                -t ${LATEST_IMAGE} \&#10;                                --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \&#10;                                --build-arg VCS_REF=$(git rev-parse --short HEAD) \&#10;                                --build-arg VERSION=${IMAGE_TAG} \&#10;                                .&#10;                            &#10;                            echo &quot;Image built successfully!&quot;&#10;                            docker images | grep registration-app&#10;                        '''&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Test') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: TEST ==========&quot;&#10;                    echo &quot;Running tests on Docker image...&quot;&#10;                    &#10;                    sh '''&#10;                        echo &quot;Verifying Docker image...&quot;&#10;                        docker inspect ${FULL_IMAGE_NAME} | head -20&#10;                        &#10;                        echo &quot;Running container health check...&quot;&#10;                        docker run --rm -d \&#10;                            --name test-container-${BUILD_NUMBER} \&#10;                            -p 5001:5000 \&#10;                            ${FULL_IMAGE_NAME} &amp;&#10;                        &#10;                        sleep 5&#10;                        &#10;                        echo &quot;Testing API endpoints...&quot;&#10;                        curl -f http://localhost:5001/health || exit 1&#10;                        curl -f http://localhost:5001/api/stats || exit 1&#10;                        &#10;                        echo &quot;Health check passed!&quot;&#10;                        docker stop test-container-${BUILD_NUMBER} || true&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Push to Registry') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: PUSH ==========&quot;&#10;                    echo &quot;Pushing image to Docker Registry: ${DOCKER_REGISTRY}&quot;&#10;                    &#10;                    sh '''&#10;                        echo &quot;Pushing image with tag ${IMAGE_TAG}...&quot;&#10;                        docker push ${FULL_IMAGE_NAME}&#10;                        &#10;                        echo &quot;Pushing image with 'latest' tag...&quot;&#10;                        docker push ${LATEST_IMAGE}&#10;                        &#10;                        echo &quot;Image pushed successfully!&quot;&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Deploy to Kubernetes') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: DEPLOY ==========&quot;&#10;                    echo &quot;Deploying to Kubernetes namespace: ${KUBE_NAMESPACE}&quot;&#10;                    &#10;                    sh '''&#10;                        echo &quot;Checking Kubernetes cluster connection...&quot;&#10;                        kubectl cluster-info&#10;                        kubectl get nodes&#10;                        &#10;                        echo &quot;Creating/updating namespace...&quot;&#10;                        kubectl create namespace ${KUBE_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -&#10;                        &#10;                        echo &quot;Applying Kubernetes manifests...&quot;&#10;                        cd ${APP_DIRECTORY}/kubernetes&#10;                        kubectl apply -f deployment.yaml -n ${KUBE_NAMESPACE}&#10;                        kubectl apply -f service.yaml -n ${KUBE_NAMESPACE}&#10;                        &#10;                        echo &quot;Updating deployment image...&quot;&#10;                        kubectl set image deployment/registration-app-deployment \&#10;                            registration-app=${FULL_IMAGE_NAME} \&#10;                            -n ${KUBE_NAMESPACE} || true&#10;                        &#10;                        echo &quot;Waiting for rollout...&quot;&#10;                        kubectl rollout status deployment/registration-app-deployment \&#10;                            -n ${KUBE_NAMESPACE} --timeout=5m&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Verify Deployment') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: VERIFY ==========&quot;&#10;                    echo &quot;Verifying deployment in Kubernetes...&quot;&#10;                    &#10;                    sh '''&#10;                        echo &quot;Checking deployment status...&quot;&#10;                        kubectl get deployment -n ${KUBE_NAMESPACE}&#10;                        &#10;                        echo &quot;Checking pods...&quot;&#10;                        kubectl get pods -n ${KUBE_NAMESPACE} -l app=registration-app&#10;                        &#10;                        echo &quot;Checking services...&quot;&#10;                        kubectl get svc -n ${KUBE_NAMESPACE}&#10;                        &#10;                        echo &quot;Pod details:&quot;&#10;                        kubectl describe pods -n ${KUBE_NAMESPACE} -l app=registration-app&#10;                        &#10;                        echo &quot;Checking pod logs...&quot;&#10;                        POD_NAME=$(kubectl get pods -n ${KUBE_NAMESPACE} -l app=registration-app -o jsonpath='{.items[0].metadata.name}')&#10;                        echo &quot;Pod name: ${POD_NAME}&quot;&#10;                        kubectl logs ${POD_NAME} -n ${KUBE_NAMESPACE} --tail=50&#10;                        &#10;                        echo &quot;Deployment verification complete!&quot;&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Health Check') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: HEALTH CHECK ==========&quot;&#10;                    echo &quot;Performing health checks on deployed pods...&quot;&#10;                    &#10;                    sh '''&#10;                        echo &quot;Testing pod connectivity...&quot;&#10;                        kubectl get svc registration-app-service -n ${KUBE_NAMESPACE}&#10;                        &#10;                        echo &quot;Port forwarding for testing...&quot;&#10;                        kubectl port-forward svc/registration-app-service 8080:80 -n ${KUBE_NAMESPACE} &amp;&#10;                        PF_PID=$!&#10;                        sleep 3&#10;                        &#10;                        echo &quot;Testing /health endpoint...&quot;&#10;                        curl -f http://localhost:8080/health || true&#10;                        &#10;                        kill $PF_PID 2&gt;/dev/null || true&#10;                        &#10;                        echo &quot;Health check complete!&quot;&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    post {&#10;        success {&#10;            echo &quot;========== BUILD SUCCESS ==========&quot;&#10;            echo &quot;Pipeline completed successfully!&quot;&#10;            echo &quot;Deployed image: ${FULL_IMAGE_NAME}&quot;&#10;            sh '''&#10;                echo &quot;=== DEPLOYMENT SUMMARY ===&quot;&#10;                echo &quot;Timestamp: $(date)&quot;&#10;                echo &quot;Build Number: ${BUILD_NUMBER}&quot;&#10;                echo &quot;Docker Image: ${FULL_IMAGE_NAME}&quot;&#10;                echo &quot;Kubernetes Namespace: ${KUBE_NAMESPACE}&quot;&#10;                echo &quot;&quot;&#10;                echo &quot;=== RUNNING PODS ===&quot;&#10;                kubectl get pods -n ${KUBE_NAMESPACE} -l app=registration-app -o wide&#10;                echo &quot;&quot;&#10;                echo &quot;=== SERVICE ENDPOINTS ===&quot;&#10;                kubectl get svc -n ${KUBE_NAMESPACE} -l app=registration-app&#10;            '''&#10;        }&#10;        failure {&#10;            echo &quot;========== BUILD FAILED ==========&quot;&#10;            echo &quot;Pipeline failed. Check logs above.&quot;&#10;            sh '''&#10;                echo &quot;=== FAILURE DETAILS ===&quot;&#10;                echo &quot;Timestamp: $(date)&quot;&#10;                echo &quot;Build Number: ${BUILD_NUMBER}&quot;&#10;                echo &quot;&quot;&#10;                echo &quot;=== POD STATUS ===&quot;&#10;                kubectl get pods -n ${KUBE_NAMESPACE} -l app=registration-app -o wide || true&#10;                echo &quot;&quot;&#10;                echo &quot;=== POD EVENTS ===&quot;&#10;                kubectl get events -n ${KUBE_NAMESPACE} --sort-by='.lastTimestamp' | tail -20 || true&#10;                echo &quot;&quot;&#10;                echo &quot;=== POD LOGS ===&quot;&#10;                POD_NAME=$(kubectl get pods -n ${KUBE_NAMESPACE} -l app=registration-app -o jsonpath='{.items[0].metadata.name}' || echo &quot;NONE&quot;)&#10;                if [ &quot;${POD_NAME}&quot; != &quot;NONE&quot; ]; then&#10;                    kubectl logs ${POD_NAME} -n ${KUBE_NAMESPACE} --tail=100 || true&#10;                fi&#10;            '''&#10;        }&#10;        always {&#10;            echo &quot;========== CLEANUP ==========&quot;&#10;            sh '''&#10;                echo &quot;Cleaning up test containers...&quot;&#10;                docker ps -a | grep test-container || true&#10;                docker rm -f test-container-${BUILD_NUMBER} 2&gt;/dev/null || true&#10;                &#10;                echo &quot;Jenkins workspace location: ${WORKSPACE}&quot;&#10;                echo &quot;Build artifacts available in workspace&quot;&#10;            '''&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="pipeline {&#10;    agent any&#10;&#10;    parameters {&#10;        string(name: 'DOCKER_REGISTRY', defaultValue: 'localhost:5000', description: 'Docker Registry URL')&#10;        string(name: 'IMAGE_NAME', defaultValue: 'registration-app', description: 'Docker Image Name')&#10;        string(name: 'KUBE_NAMESPACE', defaultValue: 'default', description: 'Kubernetes Namespace')&#10;    }&#10;&#10;    environment {&#10;        DOCKER_REGISTRY = &quot;${params.DOCKER_REGISTRY}&quot;&#10;        IMAGE_NAME = &quot;${params.IMAGE_NAME}&quot;&#10;        IMAGE_TAG = &quot;${BUILD_NUMBER}&quot;&#10;        FULL_IMAGE_NAME = &quot;${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}&quot;&#10;        LATEST_IMAGE = &quot;${DOCKER_REGISTRY}/${IMAGE_NAME}:latest&quot;&#10;        KUBE_NAMESPACE = &quot;${params.KUBE_NAMESPACE}&quot;&#10;        APP_DIRECTORY = &quot;phase-2&quot;&#10;        GIT_COMMIT_MSG = &quot;Jenkins CI/CD Pipeline Build #${BUILD_NUMBER}&quot;&#10;    }&#10;&#10;    options {&#10;        buildDiscarder(logRotator(numToKeepStr: '10'))&#10;        timestamps()&#10;        timeout(time: 30, unit: 'MINUTES')&#10;    }&#10;&#10;    stages {&#10;        stage('Checkout') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: CHECKOUT ==========&quot;&#10;                    echo &quot;Checking out code from repository...&quot;&#10;                    checkout scm&#10;                    sh '''&#10;                        echo &quot;Git branch: $(git rev-parse --abbrev-ref HEAD)&quot;&#10;                        echo &quot;Git commit: $(git rev-parse --short HEAD)&quot;&#10;                        echo &quot;Git log:&quot;&#10;                        git log --oneline -5&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Build') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: BUILD ==========&quot;&#10;                    echo &quot;Building Docker image: ${FULL_IMAGE_NAME}&quot;&#10;                    &#10;                    dir(&quot;${APP_DIRECTORY}/app&quot;) {&#10;                        sh '''&#10;                            echo &quot;Building Docker image...&quot;&#10;                            docker build \&#10;                                -t ${FULL_IMAGE_NAME} \&#10;                                -t ${LATEST_IMAGE} \&#10;                                --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \&#10;                                --build-arg VCS_REF=$(git rev-parse --short HEAD) \&#10;                                --build-arg VERSION=${IMAGE_TAG} \&#10;                                .&#10;                            &#10;                            echo &quot;Image built successfully!&quot;&#10;                            docker images | grep registration-app&#10;                        '''&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Test') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: TEST ==========&quot;&#10;                    echo &quot;Running tests on Docker image...&quot;&#10;                    &#10;                    sh '''&#10;                        echo &quot;Verifying Docker image...&quot;&#10;                        docker inspect ${FULL_IMAGE_NAME} | head -20&#10;                        &#10;                        echo &quot;Running container health check...&quot;&#10;                        docker run --rm -d \&#10;                            --name test-container-${BUILD_NUMBER} \&#10;                            -p 5001:5000 \&#10;                            ${FULL_IMAGE_NAME} &amp;&#10;                        &#10;                        sleep 5&#10;                        &#10;                        echo &quot;Testing API endpoints...&quot;&#10;                        curl -f http://localhost:5001/health || exit 1&#10;                        curl -f http://localhost:5001/api/stats || exit 1&#10;                        &#10;                        echo &quot;Health check passed!&quot;&#10;                        docker stop test-container-${BUILD_NUMBER} || true&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Push to Registry') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: PUSH ==========&quot;&#10;                    echo &quot;Pushing image to Docker Registry: ${DOCKER_REGISTRY}&quot;&#10;                    &#10;                    sh '''&#10;                        echo &quot;Pushing image with tag ${IMAGE_TAG}...&quot;&#10;                        docker push ${FULL_IMAGE_NAME}&#10;                        &#10;                        echo &quot;Pushing image with 'latest' tag...&quot;&#10;                        docker push ${LATEST_IMAGE}&#10;                        &#10;                        echo &quot;Image pushed successfully!&quot;&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Deploy to Kubernetes') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: DEPLOY ==========&quot;&#10;                    echo &quot;Deploying to Kubernetes namespace: ${KUBE_NAMESPACE}&quot;&#10;                    &#10;                    sh '''&#10;                        echo &quot;Checking Kubernetes cluster connection...&quot;&#10;                        kubectl cluster-info&#10;                        kubectl get nodes&#10;                        &#10;                        echo &quot;Creating/updating namespace...&quot;&#10;                        kubectl create namespace ${KUBE_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -&#10;                        &#10;                        echo &quot;Applying Kubernetes manifests...&quot;&#10;                        cd ${APP_DIRECTORY}/kubernetes&#10;                        kubectl apply -f deployment.yaml -n ${KUBE_NAMESPACE}&#10;                        kubectl apply -f service.yaml -n ${KUBE_NAMESPACE}&#10;                        &#10;                        echo &quot;Updating deployment image...&quot;&#10;                        kubectl set image deployment/registration-app-deployment \&#10;                            registration-app=${FULL_IMAGE_NAME} \&#10;                            -n ${KUBE_NAMESPACE} || true&#10;                        &#10;                        echo &quot;Waiting for rollout...&quot;&#10;                        kubectl rollout status deployment/registration-app-deployment \&#10;                            -n ${KUBE_NAMESPACE} --timeout=5m&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Verify Deployment') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: VERIFY ==========&quot;&#10;                    echo &quot;Verifying deployment in Kubernetes...&quot;&#10;                    &#10;                    sh '''&#10;                        echo &quot;Checking deployment status...&quot;&#10;                        kubectl get deployment -n ${KUBE_NAMESPACE}&#10;                        &#10;                        echo &quot;Checking pods...&quot;&#10;                        kubectl get pods -n ${KUBE_NAMESPACE} -l app=registration-app&#10;                        &#10;                        echo &quot;Checking services...&quot;&#10;                        kubectl get svc -n ${KUBE_NAMESPACE}&#10;                        &#10;                        echo &quot;Pod details:&quot;&#10;                        kubectl describe pods -n ${KUBE_NAMESPACE} -l app=registration-app&#10;                        &#10;                        echo &quot;Checking pod logs...&quot;&#10;                        POD_NAME=$(kubectl get pods -n ${KUBE_NAMESPACE} -l app=registration-app -o jsonpath='{.items[0].metadata.name}')&#10;                        echo &quot;Pod name: ${POD_NAME}&quot;&#10;                        kubectl logs ${POD_NAME} -n ${KUBE_NAMESPACE} --tail=50&#10;                        &#10;                        echo &quot;Deployment verification complete!&quot;&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;&#10;        stage('Health Check') {&#10;            steps {&#10;                script {&#10;                    echo &quot;========== STAGE: HEALTH CHECK ==========&quot;&#10;                    echo &quot;Performing health checks on deployed pods...&quot;&#10;                    &#10;                    sh '''&#10;                        echo &quot;Testing pod connectivity...&quot;&#10;                        kubectl get svc registration-app-service -n ${KUBE_NAMESPACE}&#10;                        &#10;                        echo &quot;Port forwarding for testing...&quot;&#10;                        kubectl port-forward svc/registration-app-service 8080:80 -n ${KUBE_NAMESPACE} &amp;&#10;                        PF_PID=$!&#10;                        sleep 3&#10;                        &#10;                        echo &quot;Testing /health endpoint...&quot;&#10;                        curl -f http://localhost:8080/health || true&#10;                        &#10;                        kill $PF_PID 2&gt;/dev/null || true&#10;                        &#10;                        echo &quot;Health check complete!&quot;&#10;                    '''&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    post {&#10;        success {&#10;            echo &quot;========== BUILD SUCCESS ==========&quot;&#10;            echo &quot;Pipeline completed successfully!&quot;&#10;            echo &quot;Deployed image: ${FULL_IMAGE_NAME}&quot;&#10;            sh '''&#10;                echo &quot;=== DEPLOYMENT SUMMARY ===&quot;&#10;                echo &quot;Timestamp: $(date)&quot;&#10;                echo &quot;Build Number: ${BUILD_NUMBER}&quot;&#10;                echo &quot;Docker Image: ${FULL_IMAGE_NAME}&quot;&#10;                echo &quot;Kubernetes Namespace: ${KUBE_NAMESPACE}&quot;&#10;                echo &quot;&quot;&#10;                echo &quot;=== RUNNING PODS ===&quot;&#10;                kubectl get pods -n ${KUBE_NAMESPACE} -l app=registration-app -o wide&#10;                echo &quot;&quot;&#10;                echo &quot;=== SERVICE ENDPOINTS ===&quot;&#10;                kubectl get svc -n ${KUBE_NAMESPACE} -l app=registration-app&#10;            '''&#10;        }&#10;        failure {&#10;            echo &quot;========== BUILD FAILED ==========&quot;&#10;            echo &quot;Pipeline failed. Check logs above.&quot;&#10;            sh '''&#10;                echo &quot;=== FAILURE DETAILS ===&quot;&#10;                echo &quot;Timestamp: $(date)&quot;&#10;                echo &quot;Build Number: ${BUILD_NUMBER}&quot;&#10;                echo &quot;&quot;&#10;                echo &quot;=== POD STATUS ===&quot;&#10;                kubectl get pods -n ${KUBE_NAMESPACE} -l app=registration-app -o wide || true&#10;                echo &quot;&quot;&#10;                echo &quot;=== POD EVENTS ===&quot;&#10;                kubectl get events -n ${KUBE_NAMESPACE} --sort-by='.lastTimestamp' | tail -20 || true&#10;                echo &quot;&quot;&#10;                echo &quot;=== POD LOGS ===&quot;&#10;                POD_NAME=$(kubectl get pods -n ${KUBE_NAMESPACE} -l app=registration-app -o jsonpath='{.items[0].metadata.name}' || echo &quot;NONE&quot;)&#10;                if [ &quot;${POD_NAME}&quot; != &quot;NONE&quot; ]; then&#10;                    kubectl logs ${POD_NAME} -n ${KUBE_NAMESPACE} --tail=100 || true&#10;                fi&#10;            '''&#10;        }&#10;        always {&#10;            echo &quot;========== CLEANUP ==========&quot;&#10;            sh '''&#10;                echo &quot;Cleaning up test containers...&quot;&#10;                docker ps -a | grep test-container || true&#10;                docker rm -f test-container-${BUILD_NUMBER} 2&gt;/dev/null || true&#10;                &#10;                echo &quot;Jenkins workspace location: ${WORKSPACE}&quot;&#10;                echo &quot;Build artifacts available in workspace&quot;&#10;            '''&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/phase-2/kubernetes/deployment.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/phase-2/kubernetes/deployment.yaml" />
              <option name="originalContent" value="apiVersion: apps/v1&#10;kind: Deployment&#10;metadata:&#10;  name: registration-app-deployment&#10;  namespace: default&#10;  labels:&#10;    app: registration-app&#10;    version: v1&#10;spec:&#10;  replicas: 3&#10;  selector:&#10;    matchLabels:&#10;      app: registration-app&#10;  template:&#10;    metadata:&#10;      labels:&#10;        app: registration-app&#10;        version: v1&#10;    spec:&#10;      containers:&#10;      - name: registration-app&#10;        image: localhost:5000/registration-app:latest&#10;        imagePullPolicy: Always&#10;        ports:&#10;        - containerPort: 5000&#10;          name: http&#10;          protocol: TCP&#10;        env:&#10;        - name: PYTHONUNBUFFERED&#10;          value: &quot;1&quot;&#10;        resources:&#10;          requests:&#10;            cpu: 100m&#10;            memory: 128Mi&#10;          limits:&#10;            cpu: 500m&#10;            memory: 512Mi&#10;        livenessProbe:&#10;          httpGet:&#10;            path: /health&#10;            port: 5000&#10;          initialDelaySeconds: 10&#10;          periodSeconds: 30&#10;          timeoutSeconds: 5&#10;          failureThreshold: 3&#10;        readinessProbe:&#10;          httpGet:&#10;            path: /health&#10;            port: 5000&#10;          initialDelaySeconds: 5&#10;          periodSeconds: 10&#10;          timeoutSeconds: 3&#10;          failureThreshold: 3&#10;        securityContext:&#10;          allowPrivilegeEscalation: false&#10;          readOnlyRootFilesystem: false&#10;          runAsNonRoot: false&#10;      restartPolicy: Always&#10;      terminationGracePeriodSeconds: 30&#10;" />
              <option name="updatedContent" value="apiVersion: apps/v1&#13;&#10;kind: Deployment&#13;&#10;metadata:&#13;&#10;  name: registration-app-deployment&#13;&#10;  namespace: default&#13;&#10;  labels:&#13;&#10;    app: registration-app&#13;&#10;    version: v1&#13;&#10;spec:&#13;&#10;  replicas: 3&#13;&#10;  selector:&#13;&#10;    matchLabels:&#13;&#10;      app: registration-app&#13;&#10;  template:&#13;&#10;    metadata:&#13;&#10;      labels:&#13;&#10;        app: registration-app&#13;&#10;        version: v1&#13;&#10;    spec:&#13;&#10;      containers:&#10;      - name: registration-app&#10;        image: localhost:5000/registration-app:latest&#10;        imagePullPolicy: Always&#13;&#10;        ports:&#13;&#10;        - containerPort: 5000&#13;&#10;          name: http&#13;&#10;          protocol: TCP&#13;&#10;        env:&#13;&#10;        - name: PYTHONUNBUFFERED&#13;&#10;          value: &quot;1&quot;&#13;&#10;        resources:&#13;&#10;          requests:&#13;&#10;            cpu: 100m&#13;&#10;            memory: 128Mi&#13;&#10;          limits:&#13;&#10;            cpu: 500m&#13;&#10;            memory: 512Mi&#13;&#10;        livenessProbe:&#13;&#10;          httpGet:&#13;&#10;            path: /health&#13;&#10;            port: 5000&#13;&#10;          initialDelaySeconds: 10&#13;&#10;          periodSeconds: 30&#13;&#10;          timeoutSeconds: 5&#13;&#10;          failureThreshold: 3&#13;&#10;        readinessProbe:&#13;&#10;          httpGet:&#13;&#10;            path: /health&#13;&#10;            port: 5000&#13;&#10;          initialDelaySeconds: 5&#13;&#10;          periodSeconds: 10&#13;&#10;          timeoutSeconds: 3&#13;&#10;          failureThreshold: 3&#13;&#10;        securityContext:&#13;&#10;          allowPrivilegeEscalation: false&#13;&#10;          readOnlyRootFilesystem: false&#13;&#10;          runAsNonRoot: false&#13;&#10;      restartPolicy: Always&#13;&#10;      terminationGracePeriodSeconds: 30&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/phase-4-cicd-README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/phase-4-cicd-README.md" />
              <option name="updatedContent" value="# Phase 4: CI/CD WAR ZONE - Jenkins Pipeline (LAB 04)&#10;&#10;## Mission Overview&#10;Push → Build → Test → Deploy like Google engineers!&#10;&#10;This phase implements a complete CI/CD pipeline using Jenkins to automate the entire workflow:&#10;1. **Code Push** → Git commit&#10;2. **Build** → Docker image creation&#10;3. **Test** → Automated testing&#10;4. **Push** → Docker registry upload&#10;5. **Deploy** → Kubernetes rollout&#10;6. **Verify** → Health checks and monitoring&#10;&#10;## Project Structure&#10;&#10;```&#10;phase-2/&#10;├── app/&#10;│   ├── main.py                # FastAPI application&#10;│   ├── Dockerfile             # Docker build definition&#10;│   ├── requirements.txt        # Python dependencies&#10;│   └── templates/&#10;│       └── index.html         # Frontend&#10;├── kubernetes/&#10;│   ├── deployment.yaml        # K8s Deployment&#10;│   └── service.yaml           # K8s Service&#10;├── Jenkinsfile               # CI/CD Pipeline definition&#10;└── docker-compose.yaml        # Local testing&#10;```&#10;&#10;## Prerequisites&#10;&#10;### Required Tools&#10;- **Jenkins** (2.387+) with Docker and Kubernetes plugins&#10;- **Docker** (20.10+) with registry access&#10;- **Kubernetes** (1.24+) cluster running locally (Minikube/Docker Desktop)&#10;- **kubectl** CLI configured&#10;- **Git** for version control&#10;&#10;### Required Jenkins Plugins&#10;```&#10;- Pipeline (workflow-aggregator)&#10;- Docker Pipeline&#10;- Kubernetes CLI&#10;- Git&#10;- Build Name and Description Setter&#10;- AnsiColor (for colored logs)&#10;- Timestamper&#10;```&#10;&#10;### Docker Registry Setup&#10;&#10;For local development, you can use Docker Registry:&#10;&#10;```bash&#10;# Start local Docker registry&#10;docker run -d -p 5000:5000 --name registry registry:2&#10;&#10;# Check if registry is running&#10;curl http://localhost:5000/v2/&#10;```&#10;&#10;## Jenkins Pipeline Stages&#10;&#10;### Stage 1: Checkout&#10;- Clones the repository&#10;- Displays Git commit information&#10;- Shows recent commit history&#10;&#10;**Output:**&#10;```&#10;Git branch: main&#10;Git commit: abc123def&#10;Git log: (last 5 commits)&#10;```&#10;&#10;### Stage 2: Build&#10;- Builds Docker image with tags&#10;- Tags image with build number and 'latest'&#10;- Includes build metadata (date, version, git ref)&#10;&#10;**Build Args:**&#10;```&#10;--build-arg BUILD_DATE=(timestamp)&#10;--build-arg VCS_REF=(git commit)&#10;--build-arg VERSION=(build number)&#10;```&#10;&#10;**Output Images:**&#10;```&#10;localhost:5000/registration-app:1234&#10;localhost:5000/registration-app:latest&#10;```&#10;&#10;### Stage 3: Test&#10;- Verifies Docker image integrity&#10;- Runs container in test environment&#10;- Tests API endpoints (/health, /api/stats)&#10;- Validates endpoints respond correctly&#10;&#10;**Tests Performed:**&#10;- Docker image inspection&#10;- Container startup&#10;- HTTP health check (curl)&#10;- API endpoint validation&#10;&#10;### Stage 4: Push&#10;- Pushes tagged image to Docker registry&#10;- Pushes 'latest' tag&#10;- Logs all push operations&#10;&#10;**Registry Push:**&#10;```&#10;docker push localhost:5000/registration-app:1234&#10;docker push localhost:5000/registration-app:latest&#10;```&#10;&#10;### Stage 5: Deploy&#10;- Connects to Kubernetes cluster&#10;- Creates/updates namespace&#10;- Applies deployment manifests&#10;- Updates deployment with new image&#10;- Waits for rollout completion (5 min timeout)&#10;&#10;**K8s Operations:**&#10;```bash&#10;kubectl apply -f deployment.yaml&#10;kubectl apply -f service.yaml&#10;kubectl set image deployment/registration-app-deployment ...&#10;kubectl rollout status deployment/registration-app-deployment&#10;```&#10;&#10;### Stage 6: Verify Deployment&#10;- Checks deployment status&#10;- Lists running pods&#10;- Displays service endpoints&#10;- Shows pod logs&#10;- Verifies image is running&#10;&#10;**Verification Steps:**&#10;```bash&#10;kubectl get deployment&#10;kubectl get pods&#10;kubectl get svc&#10;kubectl describe pods&#10;kubectl logs &lt;pod-name&gt;&#10;```&#10;&#10;### Stage 7: Health Check&#10;- Port forwards to service&#10;- Calls /health endpoint&#10;- Validates pod connectivity&#10;&#10;## Jenkins Configuration&#10;&#10;### 1. Create Jenkins Pipeline Job&#10;&#10;1. Open Jenkins UI: `http://localhost:8080`&#10;2. Click &quot;New Item&quot;&#10;3. Enter name: `registration-app-pipeline`&#10;4. Select &quot;Pipeline&quot;&#10;5. Click OK&#10;&#10;### 2. Configure Pipeline Job&#10;&#10;**Pipeline Section:**&#10;```&#10;Definition: Pipeline script from SCM&#10;SCM: Git&#10;Repository URL: &lt;your-git-repo&gt;&#10;Branch: */main&#10;Script Path: phase-2/Jenkinsfile&#10;```&#10;&#10;### 3. Configure Build Triggers&#10;&#10;- Check &quot;Poll SCM&quot;: `H/5 * * * *` (poll every 5 minutes)&#10;- OR: Check &quot;GitHub hook trigger&quot; (if using GitHub)&#10;- OR: Manual trigger for testing&#10;&#10;### 4. Configure Pipeline Parameters&#10;&#10;Optional parameters in Jenkins:&#10;- `DOCKER_REGISTRY`: localhost:5000 (default)&#10;- `IMAGE_NAME`: registration-app (default)&#10;- `KUBE_NAMESPACE`: default (default)&#10;&#10;## Running the Pipeline&#10;&#10;### Method 1: Manual Trigger (Quick Testing)&#10;&#10;```bash&#10;# 1. Make a code change&#10;echo &quot;# Updated app&quot; &gt;&gt; phase-2/app/main.py&#10;&#10;# 2. Commit and push&#10;git add phase-2/app/main.py&#10;git commit -m &quot;Jenkins CI/CD Pipeline Build - Feature update&quot;&#10;git push origin main&#10;&#10;# 3. Go to Jenkins and click &quot;Build Now&quot;&#10;```&#10;&#10;### Method 2: Automated Trigger (Poll SCM)&#10;&#10;```bash&#10;# 1. Configure &quot;Poll SCM&quot; in Jenkins (H/5 * * * *)&#10;# 2. Make changes and commit&#10;git add .&#10;git commit -m &quot;Jenkins CI/CD Pipeline Build #$(date +%s)&quot;&#10;git push origin main&#10;&#10;# Jenkins automatically detects changes and builds within 5 minutes&#10;```&#10;&#10;### Method 3: GitHub Webhook (Recommended)&#10;&#10;```bash&#10;# 1. Configure &quot;GitHub hook trigger&quot; in Jenkins&#10;# 2. Add webhook to GitHub repo settings:&#10;#    Payload URL: http://jenkins-url/github-webhook/&#10;#    Events: Push events&#10;# 3. Commit and push - Jenkins builds automatically&#10;```&#10;&#10;## Complete Workflow Example&#10;&#10;### Step 1: Make a Code Change&#10;&#10;```bash&#10;cd phase-2&#10;&#10;# Modify the application&#10;echo &quot;&#10;@app.get('/api/version')&#10;async def get_version():&#10;    return {'version': '1.0.0', 'build': '$(date +%s)'}&#10;&quot; &gt;&gt; app/main.py&#10;&#10;git add app/main.py&#10;```&#10;&#10;### Step 2: Commit and Push&#10;&#10;```bash&#10;git commit -m &quot;Jenkins CI/CD Pipeline Build #001 - Add version endpoint&quot;&#10;git push origin main&#10;```&#10;&#10;### Step 3: Trigger Jenkins&#10;&#10;**Option A: Manual**&#10;1. Go to Jenkins: `http://localhost:8080`&#10;2. Click job: `registration-app-pipeline`&#10;3. Click &quot;Build Now&quot;&#10;4. Watch the build progress&#10;&#10;**Option B: Automatic (if poll SCM configured)**&#10;- Jenkins detects change within 5 minutes&#10;- Pipeline starts automatically&#10;&#10;### Step 4: Watch Pipeline Execution&#10;&#10;```bash&#10;# In Jenkins UI, click the build number to see:&#10;# - Console Output (detailed logs)&#10;# - Stage View (visual progress)&#10;# - Build Artifacts&#10;&#10;# Or view in terminal:&#10;kubectl get pods -n default -l app=registration-app --watch&#10;```&#10;&#10;### Step 5: Verify Pod Updated&#10;&#10;```bash&#10;# Check if new pod is running&#10;kubectl get pods -n default -l app=registration-app -o wide&#10;&#10;# View pod details&#10;kubectl describe pod &lt;pod-name&gt; -n default&#10;&#10;# Check image version&#10;kubectl get pods -n default -l app=registration-app \&#10;  -o jsonpath='{.items[*].spec.containers[0].image}'&#10;&#10;# Test the service&#10;kubectl port-forward svc/registration-app-service 8080:80 -n default &amp;&#10;curl http://localhost:8080/health&#10;curl http://localhost:8080/api/version&#10;```&#10;&#10;## Required Outputs&#10;&#10;### 1. Jenkins Screenshot ✓&#10;Capture:&#10;- Jenkins job dashboard&#10;- Build history with successful builds&#10;- Latest build with all stages completed&#10;- Console output showing pipeline execution&#10;&#10;**Steps to capture:**&#10;```bash&#10;# Take screenshot showing:&#10;# - Job name: registration-app-pipeline&#10;# - Build history on left&#10;# - Latest build status: SUCCESS&#10;# - Stage View showing all stages passed&#10;# - Console output with timestamps&#10;```&#10;&#10;### 2. Git Commit ✓&#10;Show:&#10;- Commit message with build reference&#10;- Timestamp&#10;- Author information&#10;- Files changed&#10;&#10;**Verify with:**&#10;```bash&#10;git log --oneline -5&#10;git show HEAD&#10;```&#10;&#10;### 3. New Pod Running Proof ✓&#10;Show:&#10;- Pod name with new creation timestamp&#10;- Image tag/version&#10;- Pod status: Running&#10;- Ready status: 1/1 or similar&#10;- Logs showing successful startup&#10;&#10;**Verify with:**&#10;```bash&#10;# Get pods with detailed info&#10;kubectl get pods -n default -l app=registration-app -o wide&#10;&#10;# Show pod creation time&#10;kubectl get pods -n default -l app=registration-app \&#10;  -o jsonpath='{.items[*].metadata.creationTimestamp}'&#10;&#10;# Show pod image&#10;kubectl get pods -n default -l app=registration-app \&#10;  -o jsonpath='{.items[*].spec.containers[0].image}'&#10;&#10;# Show logs&#10;kubectl logs -n default &lt;pod-name&gt; --tail=50&#10;```&#10;&#10;## Troubleshooting&#10;&#10;### Build Fails at Docker Build Stage&#10;```bash&#10;# Check if Docker is running&#10;docker ps&#10;&#10;# Check Docker logs&#10;docker logs -f&#10;&#10;# Verify Dockerfile in phase-2/app/&#10;cat phase-2/app/Dockerfile&#10;```&#10;&#10;### Push Fails - Registry Connection Error&#10;```bash&#10;# Check if registry is running&#10;curl http://localhost:5000/v2/&#10;&#10;# Start registry if not running&#10;docker run -d -p 5000:5000 --name registry registry:2&#10;&#10;# Tag and push manually&#10;docker tag registration-app:latest localhost:5000/registration-app:latest&#10;docker push localhost:5000/registration-app:latest&#10;```&#10;&#10;### Deploy Fails - Kubernetes Connection Error&#10;```bash&#10;# Check kubectl configuration&#10;kubectl config current-context&#10;kubectl cluster-info&#10;&#10;# For Minikube&#10;minikube status&#10;minikube start&#10;&#10;# For Docker Desktop&#10;# Enable Kubernetes in Docker Desktop settings&#10;```&#10;&#10;### Pod Won't Start After Deploy&#10;```bash&#10;# Check pod status&#10;kubectl describe pod &lt;pod-name&gt; -n default&#10;&#10;# Check pod logs&#10;kubectl logs &lt;pod-name&gt; -n default&#10;&#10;# Check events&#10;kubectl get events -n default --sort-by='.lastTimestamp'&#10;&#10;# Check image exists in registry&#10;docker images | grep registration-app&#10;curl http://localhost:5000/v2/registration-app/tags/list&#10;```&#10;&#10;## Advanced Features&#10;&#10;### 1. Rollback Deployment&#10;```bash&#10;# View rollout history&#10;kubectl rollout history deployment/registration-app-deployment -n default&#10;&#10;# Rollback to previous revision&#10;kubectl rollout undo deployment/registration-app-deployment -n default&#10;```&#10;&#10;### 2. Monitor Pod Logs&#10;```bash&#10;# Follow logs in real-time&#10;kubectl logs -f &lt;pod-name&gt; -n default&#10;&#10;# View logs from all pods&#10;kubectl logs -l app=registration-app -n default&#10;```&#10;&#10;### 3. Run Multiple Builds&#10;```bash&#10;# First build&#10;git commit -m &quot;Jenkins CI/CD Pipeline Build #001&quot;&#10;git push&#10;&#10;# Second build&#10;git commit -m &quot;Jenkins CI/CD Pipeline Build #002&quot;&#10;git push&#10;&#10;# Jenkins automatically detects and builds&#10;```&#10;&#10;### 4. Health Monitoring&#10;```bash&#10;# Watch deployment&#10;kubectl get deployment -n default --watch&#10;&#10;# Watch pods&#10;kubectl get pods -n default --watch&#10;&#10;# Watch events&#10;kubectl get events -n default --watch&#10;```&#10;&#10;## Pipeline Architecture&#10;&#10;```&#10;┌─────────────────────────────────────┐&#10;│        Git Repository               │&#10;│   (Code push triggers pipeline)      │&#10;└──────────────┬──────────────────────┘&#10;               │&#10;               ▼&#10;         ┌─────────────┐&#10;         │  Checkout   │ Get latest code&#10;         └──────┬──────┘&#10;                │&#10;                ▼&#10;           ┌─────────┐&#10;           │  Build  │ Build Docker image&#10;           └────┬────┘&#10;                │&#10;                ▼&#10;            ┌─────────┐&#10;            │  Test   │ Run automated tests&#10;            └────┬────┘&#10;                 │&#10;                 ▼&#10;           ┌──────────┐&#10;           │   Push   │ Push to registry&#10;           └────┬─────┘&#10;                │&#10;                ▼&#10;        ┌──────────────┐&#10;        │   Deploy     │ Deploy to K8s&#10;        └────┬─────────┘&#10;             │&#10;             ▼&#10;       ┌──────────────┐&#10;       │    Verify    │ Check deployment&#10;       └────┬─────────┘&#10;            │&#10;            ▼&#10;      ┌──────────────┐&#10;      │ Health Check │ Test endpoints&#10;      └──────────────┘&#10;```&#10;&#10;## Performance Metrics&#10;&#10;**Expected Build Times:**&#10;- Checkout: ~5 seconds&#10;- Build: ~20-30 seconds&#10;- Test: ~10 seconds&#10;- Push: ~15 seconds&#10;- Deploy: ~30-60 seconds&#10;- Verify: ~15 seconds&#10;- Health Check: ~5 seconds&#10;&#10;**Total Pipeline Time: ~2-3 minutes**&#10;&#10;## Security Best Practices&#10;&#10;1. **Use Docker Registry Authentication**&#10;   ```bash&#10;   # Configure credentials in Jenkins&#10;   # Settings → Manage Credentials → Add credentials&#10;   ```&#10;&#10;2. **Use Kubernetes RBAC**&#10;   ```bash&#10;   # Create service account for Jenkins&#10;   kubectl create serviceaccount jenkins&#10;   kubectl create clusterrolebinding jenkins-admin \&#10;     --clusterrole=cluster-admin \&#10;     --serviceaccount=default:jenkins&#10;   ```&#10;&#10;3. **Secure Secrets**&#10;   - Use Jenkins Credentials for registry auth&#10;   - Use Kubernetes Secrets for sensitive data&#10;   - Never commit credentials to Git&#10;&#10;## Next Steps&#10;&#10;1. ✅ Create Jenkins job with Jenkinsfile&#10;2. ✅ Configure polling or webhook triggers&#10;3. ✅ Make first commit to trigger pipeline&#10;4. ✅ Monitor build execution&#10;5. ✅ Verify pod deployment&#10;6. ✅ Collect screenshots and proof&#10;7. ✅ Document results&#10;&#10;## References&#10;&#10;- [Jenkins Pipeline Documentation](https://www.jenkins.io/doc/book/pipeline/)&#10;- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)&#10;- [Kubernetes Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)&#10;- [FastAPI Documentation](https://fastapi.tiangolo.com/)&#10;&#10;---&#10;&#10;**Lab Created:** 2025-01-01&#10;**Version:** 1.0&#10;**Status:** Ready for CI/CD Implementation&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/phase-4-test.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/phase-4-test.ps1" />
              <option name="originalContent" value="# Phase 4: CI/CD Testing Script (PowerShell for Windows)&#10;# This script simulates the Jenkins pipeline locally for testing&#10;&#10;param(&#10;    [string]$Stage = &quot;full&quot;,&#10;    [string]$DockerRegistry = &quot;localhost:5000&quot;,&#10;    [string]$ImageName = &quot;registration-app&quot;,&#10;    [string]$KubeNamespace = &quot;default&quot;,&#10;    [string]$BuildNumber = (Get-Random -Maximum 100000),&#10;    [string]$ImageTag = $BuildNumber&#10;)&#10;&#10;$ErrorActionPreference = &quot;Stop&quot;&#10;&#10;# Configuration&#10;$FullImageName = &quot;${DockerRegistry}/${ImageName}:${ImageTag}&quot;&#10;$LatestImage = &quot;${DockerRegistry}/${ImageName}:latest&quot;&#10;&#10;Write-Host &quot;======================================&quot;&#10;Write-Host &quot;Phase 4: CI/CD Testing Script (PowerShell)&quot;&#10;Write-Host &quot;======================================&quot;&#10;Write-Host &quot;&quot;&#10;Write-Host &quot;[INFO] Configuration:&quot;&#10;Write-Host &quot;  Docker Registry: $DockerRegistry&quot;&#10;Write-Host &quot;  Image Name: $ImageName&quot;&#10;Write-Host &quot;  Build Number: $BuildNumber&quot;&#10;Write-Host &quot;  Full Image: $FullImageName&quot;&#10;Write-Host &quot;  K8s Namespace: $KubeNamespace&quot;&#10;Write-Host &quot;&quot;&#10;&#10;# Functions&#10;function Stage-Checkout {&#10;    Write-Host &quot;[STAGE] Checkout&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Git branch: $(git rev-parse --abbrev-ref HEAD)&quot;&#10;    Write-Host &quot;Git commit: $(git rev-parse --short HEAD)&quot;&#10;    Write-Host &quot;Git log:&quot;&#10;    git log --oneline -5&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-Build {&#10;    Write-Host &quot;[STAGE] Build&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Building Docker image: $FullImageName&quot;&#10;    &#10;    Push-Location &quot;phase-2\app&quot;&#10;    docker build `&#10;        -t $FullImageName `&#10;        -t $LatestImage `&#10;        --build-arg BUILD_DATE=$(Get-Date -Format &quot;o&quot;) `&#10;        --build-arg VCS_REF=$(git rev-parse --short HEAD) `&#10;        --build-arg VERSION=$ImageTag `&#10;        .&#10;    Pop-Location&#10;    &#10;    Write-Host &quot;Image built successfully!&quot;&#10;    docker images | Select-String &quot;registration-app&quot;&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-Test {&#10;    Write-Host &quot;[STAGE] Test&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Running tests on Docker image...&quot;&#10;    &#10;    docker inspect $FullImageName | Select-Object -First 20&#10;    &#10;    Write-Host &quot;Running container health check...&quot;&#10;    docker run --rm -d `&#10;        --name test-container-$BuildNumber `&#10;        -p 5001:5000 `&#10;        $FullImageName&#10;    &#10;    Start-Sleep -Seconds 5&#10;    &#10;    Write-Host &quot;Testing API endpoints...&quot;&#10;    try {&#10;        $response = curl.exe -f http://localhost:5001/health&#10;        Write-Host &quot;Health check response: $response&quot;&#10;    }&#10;    catch {&#10;        Write-Host &quot;ERROR: Health check failed&quot; -ForegroundColor Red&#10;        exit 1&#10;    }&#10;    &#10;    try {&#10;        $response = curl.exe -f http://localhost:5001/api/stats&#10;        Write-Host &quot;Stats response: $response&quot;&#10;    }&#10;    catch {&#10;        Write-Host &quot;ERROR: Stats check failed&quot; -ForegroundColor Red&#10;        exit 1&#10;    }&#10;    &#10;    Write-Host &quot;Health check passed!&quot;&#10;    docker stop test-container-$BuildNumber -ErrorAction SilentlyContinue&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-Push {&#10;    Write-Host &quot;[STAGE] Push&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Pushing image to Docker Registry: $DockerRegistry&quot;&#10;    &#10;    Write-Host &quot;Pushing image with tag $ImageTag...&quot;&#10;    docker push $FullImageName&#10;    &#10;    Write-Host &quot;Pushing image with 'latest' tag...&quot;&#10;    docker push $LatestImage&#10;    &#10;    Write-Host &quot;Image pushed successfully!&quot;&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-Deploy {&#10;    Write-Host &quot;[STAGE] Deploy&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Deploying to Kubernetes namespace: $KubeNamespace&quot;&#10;    &#10;    Write-Host &quot;Checking Kubernetes cluster connection...&quot;&#10;    kubectl cluster-info&#10;    kubectl get nodes&#10;    &#10;    Write-Host &quot;Creating/updating namespace...&quot;&#10;    kubectl create namespace $KubeNamespace --dry-run=client -o yaml | kubectl apply -f -&#10;    &#10;    Write-Host &quot;Applying Kubernetes manifests...&quot;&#10;    Push-Location &quot;phase-2\kubernetes&quot;&#10;    kubectl apply -f deployment.yaml -n $KubeNamespace&#10;    kubectl apply -f service.yaml -n $KubeNamespace&#10;    Pop-Location&#10;    &#10;    Write-Host &quot;Updating deployment image...&quot;&#10;    kubectl set image deployment/registration-app-deployment `&#10;        registration-app=$FullImageName `&#10;        -n $KubeNamespace -ErrorAction SilentlyContinue&#10;    &#10;    Write-Host &quot;Waiting for rollout...&quot;&#10;    kubectl rollout status deployment/registration-app-deployment `&#10;        -n $KubeNamespace --timeout=5m&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-Verify {&#10;    Write-Host &quot;[STAGE] Verify&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Verifying deployment in Kubernetes...&quot;&#10;    &#10;    Write-Host &quot;Checking deployment status...&quot;&#10;    kubectl get deployment -n $KubeNamespace&#10;    &#10;    Write-Host &quot;Checking pods...&quot;&#10;    kubectl get pods -n $KubeNamespace -l app=registration-app&#10;    &#10;    Write-Host &quot;Checking services...&quot;&#10;    kubectl get svc -n $KubeNamespace&#10;    &#10;    Write-Host &quot;Pod details:&quot;&#10;    kubectl describe pods -n $KubeNamespace -l app=registration-app&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-HealthCheck {&#10;    Write-Host &quot;[STAGE] Health Check&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Performing health checks on deployed pods...&quot;&#10;    &#10;    Write-Host &quot;Testing pod connectivity...&quot;&#10;    $port = kubectl port-forward svc/registration-app-service 8080:80 -n $KubeNamespace&#10;    Start-Sleep -Seconds 3&#10;    &#10;    Write-Host &quot;Testing /health endpoint...&quot;&#10;    try {&#10;        curl.exe -f http://localhost:8080/health&#10;    }&#10;    catch {&#10;        Write-Host &quot;Health check failed (expected if pods still starting)&quot; -ForegroundColor Yellow&#10;    }&#10;    &#10;    Write-Host &quot;Health check complete!&quot;&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;# Main execution&#10;switch ($Stage) {&#10;    &quot;checkout&quot; { Stage-Checkout }&#10;    &quot;build&quot; { Stage-Build }&#10;    &quot;test&quot; { Stage-Test }&#10;    &quot;push&quot; { Stage-Push }&#10;    &quot;deploy&quot; { Stage-Deploy }&#10;    &quot;verify&quot; { Stage-Verify }&#10;    &quot;health&quot; { Stage-HealthCheck }&#10;    &quot;full&quot; {&#10;        Stage-Checkout&#10;        Stage-Build&#10;        Stage-Test&#10;        Stage-Push&#10;        Stage-Deploy&#10;        Stage-Verify&#10;        Stage-HealthCheck&#10;    }&#10;    default {&#10;        Write-Host &quot;Usage: .\phase-4-test.ps1 -Stage {checkout|build|test|push|deploy|verify|health|full}&quot;&#10;        exit 1&#10;    }&#10;}&#10;&#10;Write-Host &quot;======================================&quot;&#10;Write-Host &quot;Pipeline Stage Complete!&quot; -ForegroundColor Green&#10;Write-Host &quot;======================================&quot;&#10;" />
              <option name="updatedContent" value="# Phase 4: CI/CD Testing Script (PowerShell for Windows)&#10;# This script simulates the Jenkins pipeline locally for testing&#10;&#10;param(&#10;    [string]$Stage = &quot;full&quot;,&#10;    [string]$DockerRegistry = &quot;localhost:5000&quot;,&#10;    [string]$ImageName = &quot;registration-app&quot;,&#10;    [string]$KubeNamespace = &quot;default&quot;,&#10;    [string]$BuildNumber = (Get-Random -Maximum 100000),&#10;    [string]$ImageTag = $BuildNumber&#10;)&#10;&#10;$ErrorActionPreference = &quot;Stop&quot;&#10;&#10;# Configuration&#10;$FullImageName = &quot;${DockerRegistry}/${ImageName}:${ImageTag}&quot;&#10;$LatestImage = &quot;${DockerRegistry}/${ImageName}:latest&quot;&#10;&#10;Write-Host &quot;======================================&quot;&#10;Write-Host &quot;Phase 4: CI/CD Testing Script (PowerShell)&quot;&#10;Write-Host &quot;======================================&quot;&#10;Write-Host &quot;&quot;&#10;Write-Host &quot;[INFO] Configuration:&quot;&#10;Write-Host &quot;  Docker Registry: $DockerRegistry&quot;&#10;Write-Host &quot;  Image Name: $ImageName&quot;&#10;Write-Host &quot;  Build Number: $BuildNumber&quot;&#10;Write-Host &quot;  Full Image: $FullImageName&quot;&#10;Write-Host &quot;  K8s Namespace: $KubeNamespace&quot;&#10;Write-Host &quot;&quot;&#10;&#10;# Functions&#10;function Stage-Checkout {&#10;    Write-Host &quot;[STAGE] Checkout&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Git branch: $(git rev-parse --abbrev-ref HEAD)&quot;&#10;    Write-Host &quot;Git commit: $(git rev-parse --short HEAD)&quot;&#10;    Write-Host &quot;Git log:&quot;&#10;    git log --oneline -5&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-Build {&#10;    Write-Host &quot;[STAGE] Build&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Building Docker image: $FullImageName&quot;&#10;    &#10;    Push-Location &quot;phase-2\app&quot;&#10;    docker build `&#10;        -t $FullImageName `&#10;        -t $LatestImage `&#10;        --build-arg BUILD_DATE=$(Get-Date -Format &quot;o&quot;) `&#10;        --build-arg VCS_REF=$(git rev-parse --short HEAD) `&#10;        --build-arg VERSION=$ImageTag `&#10;        .&#10;    Pop-Location&#10;    &#10;    Write-Host &quot;Image built successfully!&quot;&#10;    docker images | Select-String &quot;registration-app&quot;&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-Test {&#10;    Write-Host &quot;[STAGE] Test&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Running tests on Docker image...&quot;&#10;    &#10;    docker inspect $FullImageName | Select-Object -First 20&#10;    &#10;    Write-Host &quot;Running container health check...&quot;&#10;    docker run --rm -d `&#10;        --name test-container-$BuildNumber `&#10;        -p 5001:5000 `&#10;        $FullImageName&#10;    &#10;    Start-Sleep -Seconds 5&#10;    &#10;    Write-Host &quot;Testing API endpoints...&quot;&#10;    try {&#10;        $response = curl.exe -f http://localhost:5001/health&#10;        Write-Host &quot;Health check response: $response&quot;&#10;    }&#10;    catch {&#10;        Write-Host &quot;ERROR: Health check failed&quot; -ForegroundColor Red&#10;        exit 1&#10;    }&#10;    &#10;    try {&#10;        $response = curl.exe -f http://localhost:5001/api/stats&#10;        Write-Host &quot;Stats response: $response&quot;&#10;    }&#10;    catch {&#10;        Write-Host &quot;ERROR: Stats check failed&quot; -ForegroundColor Red&#10;        exit 1&#10;    }&#10;    &#10;    Write-Host &quot;Health check passed!&quot;&#10;    docker stop test-container-$BuildNumber -ErrorAction SilentlyContinue&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-Push {&#10;    Write-Host &quot;[STAGE] Push&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Pushing image to Docker Registry: $DockerRegistry&quot;&#10;    &#10;    Write-Host &quot;Pushing image with tag $ImageTag...&quot;&#10;    docker push $FullImageName&#10;    &#10;    Write-Host &quot;Pushing image with 'latest' tag...&quot;&#10;    docker push $LatestImage&#10;    &#10;    Write-Host &quot;Image pushed successfully!&quot;&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-Deploy {&#10;    Write-Host &quot;[STAGE] Deploy&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Deploying to Kubernetes namespace: $KubeNamespace&quot;&#10;    &#10;    Write-Host &quot;Checking Kubernetes cluster connection...&quot;&#10;    kubectl cluster-info&#10;    kubectl get nodes&#10;    &#10;    Write-Host &quot;Creating/updating namespace...&quot;&#10;    kubectl create namespace $KubeNamespace --dry-run=client -o yaml | kubectl apply -f -&#10;    &#10;    Write-Host &quot;Applying Kubernetes manifests...&quot;&#10;    Push-Location &quot;phase-2\kubernetes&quot;&#10;    kubectl apply -f deployment.yaml -n $KubeNamespace&#10;    kubectl apply -f service.yaml -n $KubeNamespace&#10;    Pop-Location&#10;    &#10;    Write-Host &quot;Updating deployment image...&quot;&#10;    kubectl set image deployment/registration-app-deployment `&#10;        registration-app=$FullImageName `&#10;        -n $KubeNamespace -ErrorAction SilentlyContinue&#10;    &#10;    Write-Host &quot;Waiting for rollout...&quot;&#10;    kubectl rollout status deployment/registration-app-deployment `&#10;        -n $KubeNamespace --timeout=5m&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-Verify {&#10;    Write-Host &quot;[STAGE] Verify&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Verifying deployment in Kubernetes...&quot;&#10;    &#10;    Write-Host &quot;Checking deployment status...&quot;&#10;    kubectl get deployment -n $KubeNamespace&#10;    &#10;    Write-Host &quot;Checking pods...&quot;&#10;    kubectl get pods -n $KubeNamespace -l app=registration-app&#10;    &#10;    Write-Host &quot;Checking services...&quot;&#10;    kubectl get svc -n $KubeNamespace&#10;    &#10;    Write-Host &quot;Pod details:&quot;&#10;    kubectl describe pods -n $KubeNamespace -l app=registration-app&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;function Stage-HealthCheck {&#10;    Write-Host &quot;[STAGE] Health Check&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;Performing health checks on deployed pods...&quot;&#10;    &#10;    Write-Host &quot;Testing pod connectivity...&quot;&#10;    $port = kubectl port-forward svc/registration-app-service 8080:80 -n $KubeNamespace&#10;    Start-Sleep -Seconds 3&#10;    &#10;    Write-Host &quot;Testing /health endpoint...&quot;&#10;    try {&#10;        curl.exe -f http://localhost:8080/health&#10;    }&#10;    catch {&#10;        Write-Host &quot;Health check failed (expected if pods still starting)&quot; -ForegroundColor Yellow&#10;    }&#10;    &#10;    Write-Host &quot;Health check complete!&quot;&#10;    Write-Host &quot;&quot;&#10;}&#10;&#10;# Main execution&#10;switch ($Stage) {&#10;    &quot;checkout&quot; { Stage-Checkout }&#10;    &quot;build&quot; { Stage-Build }&#10;    &quot;test&quot; { Stage-Test }&#10;    &quot;push&quot; { Stage-Push }&#10;    &quot;deploy&quot; { Stage-Deploy }&#10;    &quot;verify&quot; { Stage-Verify }&#10;    &quot;health&quot; { Stage-HealthCheck }&#10;    &quot;full&quot; {&#10;        Stage-Checkout&#10;        Stage-Build&#10;        Stage-Test&#10;        Stage-Push&#10;        Stage-Deploy&#10;        Stage-Verify&#10;        Stage-HealthCheck&#10;    }&#10;    default {&#10;        Write-Host &quot;Usage: .\phase-4-test.ps1 -Stage {checkout|build|test|push|deploy|verify|health|full}&quot;&#10;        exit 1&#10;    }&#10;}&#10;&#10;Write-Host &quot;======================================&quot;&#10;Write-Host &quot;Pipeline Stage Complete!&quot; -ForegroundColor Green&#10;Write-Host &quot;======================================&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>